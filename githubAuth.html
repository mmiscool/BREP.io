<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GitHub Repo File Editor (Token, CDN-only)</title>
  <style>
    /* Layout only */
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    header { padding: 10px; border-bottom: 1px solid #ccc; }
    main { padding: 10px; }
    .grid { display: grid; grid-template-columns: 380px 1fr; gap: 10px; align-items: start; }
    @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }
    .panel { border: 1px solid #ccc; padding: 10px; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .stack > * { margin-bottom: 8px; }
    .stack > *:last-child { margin-bottom: 0; }
    textarea { width: 100%; height: 520px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    select, input[type="text"], input[type="password"] { width: 100%; }
    .fileList { border: 1px solid #ccc; height: 360px; overflow: auto; padding: 6px; }
    .fileItem { padding: 6px; border-bottom: 1px solid #eee; cursor: pointer; }
    .fileItem:hover { background: #f5f5f5; }
    .crumbs { display: flex; gap: 6px; flex-wrap: wrap; }
    .crumb { cursor: pointer; text-decoration: underline; }
    .status { white-space: pre-wrap; border: 1px solid #ddd; padding: 8px; }
  </style>
</head>

<body>
<header>
  <strong>GitHub Repo File Editor (Token, CDN-only)</strong>
  <div>Paste a GitHub token (fine-grained PAT recommended). No OAuth, no backend.</div>
</header>

<main>
  <div class="grid">
    <!-- LEFT -->
    <section class="panel stack">
      <div>
        <strong>1) Authenticate (Token)</strong>
      </div>

      <div>
        <label for="token">GitHub Token</label><br />
        <input
          id="token"
          type="password"
          placeholder="Paste token here"
          autocomplete="off"
          autocorrect="off"
          autocapitalize="off"
          spellcheck="false"
        />
        <div class="row" style="margin-top:6px;">
          <button id="btnUseToken">Use token</button>
          <button id="btnClearToken">Clear</button>
          <label style="display:flex;align-items:center;gap:6px;">
            <input type="checkbox" id="rememberToken" />
            Remember in session (tab only)
          </label>
        </div>
      </div>

      <div id="authStatus" class="status" style="display:none;"></div>

      <hr />

      <div>
        <strong>2) Select repo</strong>
      </div>

      <div>
        <label for="repoSelect">Repositories</label><br />
        <select id="repoSelect" disabled>
          <option value="">Sign in first</option>
        </select>
        <div class="row" style="margin-top:6px;">
          <button id="btnReloadRepos" disabled>Reload repos</button>
          <label style="display:flex;align-items:center;gap:6px;">
            <input type="checkbox" id="onlyPushable" />
            Only show repos I can push to
          </label>
        </div>
      </div>

      <hr />

      <div>
        <strong>3) Browse files</strong>
        <div class="row" style="margin-top:6px;">
          <button id="btnRefreshFiles" disabled>Refresh</button>
          <label style="display:flex;align-items:center;gap:6px;">
            Branch:
            <input id="branch" type="text" placeholder="(default branch)" style="width:180px;" />
          </label>
        </div>
      </div>

      <div id="crumbs" class="crumbs" style="display:none;"></div>
      <div id="fileList" class="fileList" style="display:none;"></div>

      <div id="browseStatus" class="status" style="display:none;"></div>
    </section>

    <!-- RIGHT -->
    <section class="panel stack">
      <div>
        <strong>4) Edit & write back</strong>
      </div>

      <div>
        <label>Loaded file</label><br />
        <input id="loadedFile" type="text" readonly value="(none)" />
      </div>

      <div>
        <label for="commitMsg">Commit message</label><br />
        <input id="commitMsg" type="text" placeholder="Update <path>" />
        <div class="row" style="margin-top:6px;">
          <button id="btnReloadFile" disabled>Reload file</button>
          <button id="btnSave" disabled>Save</button>
        </div>
      </div>

      <div>
        <label for="editor">File contents</label><br />
        <textarea id="editor" disabled placeholder="Load a file to edit it..."></textarea>
      </div>

      <div id="editStatus" class="status" style="display:none;"></div>
    </section>
  </div>
</main>

<script>
/**
 * Token-based GitHub file editor (browser-only).
 * Works from a CDN because it only calls api.github.com (CORS allowed).
 */

const GH = {
  apiBase: "https://api.github.com",
  apiVersion: "2022-11-28",
};

const els = {
  token: document.getElementById("token"),
  btnUseToken: document.getElementById("btnUseToken"),
  btnClearToken: document.getElementById("btnClearToken"),
  rememberToken: document.getElementById("rememberToken"),
  authStatus: document.getElementById("authStatus"),

  repoSelect: document.getElementById("repoSelect"),
  btnReloadRepos: document.getElementById("btnReloadRepos"),
  onlyPushable: document.getElementById("onlyPushable"),

  btnRefreshFiles: document.getElementById("btnRefreshFiles"),
  branch: document.getElementById("branch"),
  crumbs: document.getElementById("crumbs"),
  fileList: document.getElementById("fileList"),
  browseStatus: document.getElementById("browseStatus"),

  loadedFile: document.getElementById("loadedFile"),
  commitMsg: document.getElementById("commitMsg"),
  btnReloadFile: document.getElementById("btnReloadFile"),
  btnSave: document.getElementById("btnSave"),
  editor: document.getElementById("editor"),
  editStatus: document.getElementById("editStatus"),
};

const state = {
  token: null,
  user: null,
  repos: [],
  repoFull: null, // "owner/repo"
  repo: null, // {owner, repo}
  defaultBranch: null,
  currentRef: null,
  currentDir: "",
  loaded: { path: null, sha: null, text: null },
};

function show(el, text) {
  el.style.display = "block";
  el.textContent = text;
}
function hide(el) {
  el.style.display = "none";
  el.textContent = "";
}

function authHeaders(token) {
  return {
    "Accept": "application/vnd.github+json",
    "Authorization": `Bearer ${token}`,
    "X-GitHub-Api-Version": GH.apiVersion,
  };
}

async function ghFetch(url, token, opts = {}) {
  const res = await fetch(url, {
    ...opts,
    headers: { ...(opts.headers || {}), ...authHeaders(token) },
  });
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`HTTP ${res.status} ${res.statusText}\n${url}\n\n${text}`);
  }
  const ct = res.headers.get("content-type") || "";
  if (ct.includes("application/json")) return await res.json();
  return await res.text();
}

async function ghFetchAllPages(url, token) {
  let out = [];
  let next = url;
  while (next) {
    const res = await fetch(next, { headers: authHeaders(token) });
    if (!res.ok) {
      const text = await res.text();
      throw new Error(`HTTP ${res.status} ${res.statusText}\n${next}\n\n${text}`);
    }
    out = out.concat(await res.json());
    next = null;
    const link = res.headers.get("link");
    if (link) {
      for (const part of link.split(",").map(s => s.trim())) {
        const m = part.match(/<([^>]+)>;\s*rel="([^"]+)"/);
        if (m && m[2] === "next") next = m[1];
      }
    }
  }
  return out;
}

function base64EncodeUtf8(str) {
  const bytes = new TextEncoder().encode(str);
  let binary = "";
  for (const b of bytes) binary += String.fromCharCode(b);
  return btoa(binary);
}
function base64DecodeUtf8(b64) {
  const binary = atob(b64);
  const bytes = new Uint8Array([...binary].map(ch => ch.charCodeAt(0)));
  return new TextDecoder().decode(bytes);
}

function parseRepo(full) {
  const [owner, repo] = String(full).split("/");
  if (!owner || !repo) return null;
  return { owner, repo };
}

function joinPath(a, b) {
  if (!a) return b || "";
  if (!b) return a;
  return a.replace(/\/+$/,"") + "/" + b.replace(/^\/+/,"");
}

function resetRepoUI() {
  els.repoSelect.innerHTML = `<option value="">Sign in first</option>`;
  els.repoSelect.disabled = true;
  els.btnReloadRepos.disabled = true;

  els.btnRefreshFiles.disabled = true;
  els.crumbs.style.display = "none";
  els.fileList.style.display = "none";
  els.fileList.innerHTML = "";
  hide(els.browseStatus);

  clearLoaded();
}

function clearLoaded() {
  state.loaded = { path: null, sha: null, text: null };
  els.loadedFile.value = "(none)";
  els.editor.value = "";
  els.editor.disabled = true;
  els.btnReloadFile.disabled = true;
  els.btnSave.disabled = true;
  els.commitMsg.value = "";
  hide(els.editStatus);
}

// ---- Auth (token) ----

async function useToken(token) {
  state.token = token;
  show(els.authStatus, "Validating token...");
  resetRepoUI();

  const user = await ghFetch(`${GH.apiBase}/user`, token);
  state.user = user;
  show(els.authStatus, `Signed in as: @${user.login}\nNow loading repositories...`);

  await loadRepos();
  show(els.authStatus, `Signed in as: @${user.login}\nRepos loaded: ${state.repos.length}`);
}

function clearToken() {
  state.token = null;
  state.user = null;
  state.repos = [];
  sessionStorage.removeItem("gh_token");
  els.token.value = "";
  els.rememberToken.checked = false;
  hide(els.authStatus);
  resetRepoUI();
}

// ---- Repo list ----

function renderRepoSelect() {
  const onlyPushable = els.onlyPushable.checked;
  const repos = onlyPushable
    ? state.repos.filter(r => r.permissions && r.permissions.push)
    : state.repos.slice();

  repos.sort((a,b) => a.full_name.localeCompare(b.full_name));

  els.repoSelect.innerHTML = `<option value="">Select a repo</option>` + repos.map(r => {
    const tag = r.private ? "private" : "public";
    const push = (r.permissions && r.permissions.push) ? "push" : "no-push";
    return `<option value="${escapeHtml(r.full_name)}">${escapeHtml(r.full_name)} (${tag}, ${push})</option>`;
  }).join("");

  els.repoSelect.disabled = false;
  els.btnReloadRepos.disabled = false;
}

async function loadRepos() {
  hide(els.browseStatus);
  els.repoSelect.disabled = true;
  els.repoSelect.innerHTML = `<option value="">Loading...</option>`;

  const url = `${GH.apiBase}/user/repos?per_page=100&sort=updated&direction=desc`;
  const repos = await ghFetchAllPages(url, state.token);
  state.repos = repos;
  renderRepoSelect();
}

// ---- Browse contents ----

async function selectRepo(full) {
  clearLoaded();
  hide(els.browseStatus);

  state.repoFull = full || null;
  state.repo = full ? parseRepo(full) : null;
  state.currentDir = "";
  state.defaultBranch = null;

  if (!state.repo) {
    els.btnRefreshFiles.disabled = true;
    els.crumbs.style.display = "none";
    els.fileList.style.display = "none";
    return;
  }

  show(els.browseStatus, "Loading repo metadata...");
  const { owner, repo } = state.repo;
  const meta = await ghFetch(`${GH.apiBase}/repos/${owner}/${repo}`, state.token);
  state.defaultBranch = meta.default_branch || "main";
  hide(els.browseStatus);

  els.btnRefreshFiles.disabled = false;
  await refreshFiles();
}

function currentRef() {
  const typed = (els.branch.value || "").trim();
  return typed || state.defaultBranch || "main";
}

function renderCrumbs(path) {
  const parts = path ? path.split("/").filter(Boolean) : [];
  els.crumbs.style.display = "flex";
  els.crumbs.innerHTML = "";

  const root = document.createElement("span");
  root.className = "crumb";
  root.textContent = "root";
  root.addEventListener("click", async () => {
    state.currentDir = "";
    await refreshFiles();
  });
  els.crumbs.appendChild(root);

  let acc = "";
  for (const part of parts) {
    const sep = document.createElement("span");
    sep.textContent = ">";
    els.crumbs.appendChild(sep);

    acc = joinPath(acc, part);
    const c = document.createElement("span");
    c.className = "crumb";
    c.textContent = part;
    c.addEventListener("click", async () => {
      state.currentDir = acc;
      await refreshFiles();
    });
    els.crumbs.appendChild(c);
  }
}

async function refreshFiles() {
  if (!state.repo) return;

  const ref = currentRef();
  state.currentRef = ref;

  const { owner, repo } = state.repo;
  const dir = state.currentDir;

  show(els.browseStatus, `Listing: ${owner}/${repo}/${dir || "(root)"} @ ${ref}`);
  const url = new URL(`${GH.apiBase}/repos/${owner}/${repo}/contents/${dir}`);
  url.searchParams.set("ref", ref);

  const data = await ghFetch(url.toString(), state.token);
  if (!Array.isArray(data)) throw new Error("This path is not a directory.");

  data.sort((a,b) => {
    if (a.type !== b.type) return a.type === "dir" ? -1 : 1;
    return a.name.localeCompare(b.name);
  });

  renderCrumbs(dir);
  renderFileList(data);

  hide(els.browseStatus);
}

function renderFileList(items) {
  els.fileList.style.display = "block";
  els.fileList.innerHTML = "";
  for (const it of items) {
    const div = document.createElement("div");
    div.className = "fileItem";
    div.textContent = `${it.type === "dir" ? "[DIR] " : "[FILE] "}${it.name}`;
    div.addEventListener("click", async () => {
      try {
        hide(els.editStatus);
        if (it.type === "dir") {
          state.currentDir = it.path;
          await refreshFiles();
        } else if (it.type === "file") {
          await loadFile(it.path);
        } else {
          show(els.browseStatus, `Unsupported type: ${it.type}`);
        }
      } catch (e) {
        show(els.editStatus, String(e.message || e));
      }
    });
    els.fileList.appendChild(div);
  }
}

// ---- Load & Save file ----

async function loadFile(path) {
  if (!state.repo) return;
  const ref = currentRef();
  const { owner, repo } = state.repo;

  show(els.editStatus, `Loading file: ${path}\nRef: ${ref}`);
  els.editor.disabled = true;
  els.btnReloadFile.disabled = true;
  els.btnSave.disabled = true;

  const url = new URL(`${GH.apiBase}/repos/${owner}/${repo}/contents/${path}`);
  url.searchParams.set("ref", ref);

  const data = await ghFetch(url.toString(), state.token);
  if (!data || data.type !== "file") throw new Error("Not a file.");

  const b64 = String(data.content || "").replace(/\n/g, "");
  const text = base64DecodeUtf8(b64);

  state.loaded = { path: data.path, sha: data.sha, text };
  els.loadedFile.value = data.path;
  els.editor.value = text;
  els.editor.disabled = false;

  els.commitMsg.value = `Update ${data.path}`;
  els.btnReloadFile.disabled = false;
  els.btnSave.disabled = false;

  show(els.editStatus, `Loaded.\nPath: ${data.path}\nsha: ${data.sha}\nRef: ${ref}`);
}

async function reloadFile() {
  if (!state.loaded.path) return;
  await loadFile(state.loaded.path);
}

async function saveFile() {
  if (!state.repo || !state.loaded.path) return;

  const ref = currentRef();
  const { owner, repo } = state.repo;

  const path = state.loaded.path;
  const sha = state.loaded.sha;
  const message = (els.commitMsg.value || "").trim() || `Update ${path}`;
  const text = els.editor.value;

  show(els.editStatus, `Saving...\nPath: ${path}\nBranch: ${ref}\nMessage: ${message}`);
  els.btnSave.disabled = true;

  const url = `${GH.apiBase}/repos/${owner}/${repo}/contents/${path}`;
  const body = {
    message,
    content: base64EncodeUtf8(text),
    branch: ref,
    sha,
  };

  const res = await fetch(url, {
    method: "PUT",
    headers: { ...authHeaders(state.token), "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });

  if (!res.ok) {
    const err = await res.text();
    els.btnSave.disabled = false;
    throw new Error(`Save failed: HTTP ${res.status} ${res.statusText}\n\n${err}`);
  }

  const data = await res.json();
  const newSha = data?.content?.sha;
  if (newSha) state.loaded.sha = newSha;

  els.btnSave.disabled = false;
  show(els.editStatus, `Saved.\nPath: ${path}\nNew sha: ${state.loaded.sha}\nCommit: ${data?.commit?.sha || "(unknown)"}\nBranch: ${ref}`);
}

// ---- Events ----

els.btnUseToken.addEventListener("click", async () => {
  try {
    const token = (els.token.value || "").trim();
    if (!token) { show(els.authStatus, "Paste a token first."); return; }

    await useToken(token);

    if (els.rememberToken.checked) {
      sessionStorage.setItem("gh_token", token);
    } else {
      sessionStorage.removeItem("gh_token");
    }
  } catch (e) {
    show(els.authStatus, String(e.message || e));
    clearLoaded();
  }
});

els.btnClearToken.addEventListener("click", () => clearToken());

els.rememberToken.addEventListener("change", () => {
  if (!els.rememberToken.checked) sessionStorage.removeItem("gh_token");
  else if (state.token) sessionStorage.setItem("gh_token", state.token);
});

els.btnReloadRepos.addEventListener("click", async () => {
  try {
    if (!state.token) return;
    show(els.authStatus, `Signed in as: @${state.user?.login || "?"}\nReloading repos...`);
    await loadRepos();
    show(els.authStatus, `Signed in as: @${state.user?.login || "?"}\nRepos loaded: ${state.repos.length}`);
  } catch (e) {
    show(els.authStatus, String(e.message || e));
  }
});

els.onlyPushable.addEventListener("change", () => {
  if (!state.repos.length) return;
  renderRepoSelect();
});

els.repoSelect.addEventListener("change", async (e) => {
  try {
    await selectRepo(e.target.value);
  } catch (err) {
    show(els.browseStatus, String(err.message || err));
  }
});

els.btnRefreshFiles.addEventListener("click", async () => {
  try {
    await refreshFiles();
  } catch (e) {
    show(els.browseStatus, String(e.message || e));
  }
});

els.branch.addEventListener("keydown", async (e) => {
  if (e.key === "Enter") {
    try {
      clearLoaded();
      await refreshFiles();
    } catch (err) {
      show(els.browseStatus, String(err.message || err));
    }
  }
});

els.btnReloadFile.addEventListener("click", async () => {
  try {
    await reloadFile();
  } catch (e) {
    show(els.editStatus, String(e.message || e));
  }
});

els.btnSave.addEventListener("click", async () => {
  try {
    await saveFile();
  } catch (e) {
    els.btnSave.disabled = false;
    show(els.editStatus, String(e.message || e));
  }
});

// ---- Session restore ----
(function restore() {
  const tok = sessionStorage.getItem("gh_token");
  if (tok) {
    els.token.value = tok;
    els.rememberToken.checked = true;
    // Do not auto-run unless you want it. If you do want it, uncomment:
    // els.btnUseToken.click();
    show(els.authStatus, "Token found in sessionStorage. Click 'Use token' to sign in.");
    els.authStatus.style.display = "block";
  }
})();

function escapeHtml(s) {
  return String(s)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

// Initial
resetRepoUI();
</script>
</body>
</html>
